# 0x03. Log Parsing

## Task

Write a script that reads stdin line by line and computes metrics:

- Input format: `<IP Address> - [<date>] "GET /projects/260 HTTP/1.1" <status code> <file size>` (if the format is not this one, the line must be skipped)
- After every 10 lines and/or a keyboard interruption (`CTRL + C`), print these statistics from the beginning:
	- Total file size: `File size: <total size>`
	- where `<total size>` is the sum of all previous `<file size>` (see input format above)
	- Number of lines by status code:
		- possible status code: `200, 301, 400, 401, 403, 404, 405 and 500`
		- if a status code doesnâ€™t appear or is not an integer, donâ€™t print anything for this status code
		- format: `<status code>: <number>`
		- status codes should be printed in ascending order


## Approach

I admit that I have slightly over-engineered this solution. It's just that a regex solution would've been so boring ðŸ˜….
I have been experimenting with writing language parsers recently, and decided to apply some of that knowledge to this problem.. and it worked perfectly.
I argue that despite the percieved complexity, this solution is
- more extensible than an alternative regex solution
- allows for much nicer error handling and syntactic analysis
- and is actually simpler than a convoluted regex hack once you understand the high level design.

The bulk of the parsing logic can be found in the `logParser` package.
- The `lexer` module houses the `Lexer` class which is responsible for generating tokens from the input string.
- The `parser` module houses the `Parser` class which is responsible for syntactic analysis of the tokens generated by the `lexer`
- The `token` module defines our `Token` class as well as the `TokenType` enum representing the atoms of our application.

If you're struggling to understand the concepts, I advise to do some light reading on parsers.

That's all folks!!
